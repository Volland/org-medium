#+TITLE: org-sendto-medium: publish to Medium from Org-Mode
#+AUTHOR: Haoyang Xu

* Usage

  Clone the repo, tangle this file:

  #+BEGIN_SRC elisp :tangle no
  (org-babel-tangle)
  #+END_SRC
  
  Put generated ~.el~ file in your load-path.

  Get an integration token from the bottom of [[https://medium.com/me/settings][your Medium settings page]].

  Put the following into your ~.emacs~:

  #+BEGIN_SRC elisp :tangle no
  (require 'org-sendto-medium)
  (setq org-medium-integration-token "2dae023f889cc2be695d39042a49b2ba3863022335c804a31daa4dfe439e2fd66")
  #+END_SRC

  Of course, you should use your own token.

  In Org-Mode, you can use 'org-sendto-medium' to publish current file to Medium.
  
* Code
  :PROPERTIES:
  :tangle:   org-sendto-medium.el
  :END:
** Preamble
   The header of the file must conform to the Emacs Lisp library header conventions. See references for more information.
   
   #+BEGIN_SRC elisp
     ;;; org-sendto-medium.el --- Export articles in Org-Mode to Medium
     ;; Copyright (C) 2016 Haoyang Xu

     ;; Author: Haoyang Xu <haoyang@expoundite.net>
     ;; Created: 22 Mar 2016
     ;; Version: 0.1
     ;; Package-Requires: ((org "8.0")(emacs "24.1"))

     ;; Keywords: comm, processes
     ;; Homepage: https://github.com/celadevra/org-sendto-medium

     ;; This file is not part of GNU Emacs.

     ;;; Commentary:

     ;; This package provides a function to publish Org-Mode files to Medium.com.
     
     ;;; Code:
   #+END_SRC
** Requirements
   This package uses ~url.el~ for request/response handling, and ~json.el~ for parsing responses.
   #+BEGIN_SRC elisp
     (require 'url)
     (require 'json)
   #+END_SRC
** Variables
*** API Endpoint Beginning
    Use a variable to store the beginning of API Endpoint, for ease of upgrade later:
    #+BEGIN_SRC elisp
      (defvar org-medium-apibegin "https://api.medium.com/v1"
        "Beginning of the Medium API endpoints. The part from 'https://' to the end of version indicator.")
    #+END_SRC
    
*** Endpoint for getting user ID
    #+BEGIN_SRC elisp
      (defvar org-medium-apiuser (concat org-medium-apibegin "/me")
        "API Endpoint for obtaining user information, such as ID.")
    #+END_SRC
*** Authentication
    As a desktop application, this package uses Medium's 'self-issued access tokens' to authenticate the user and let Medium API know it is talking to an agent who is on behalf of some user. A variable ~org-medium-integration-token~ is used to store the token.
    
    Save token in a variable:
    #+BEGIN_SRC elisp
      (defvar org-medium-integration-token ""
        "Self-issued token for authentication with Medium. You can generate yours at https://medium.com/me/settings")
    #+END_SRC
    
    #+PROPERTY: comments org
    
    With correct integration token, Medium's user information API endpoint will send us a series of data, we are storing the "id" data in this variable:
    #+BEGIN_SRC elisp
      (defvar org-medium-author-id nil
        "Author id returned by Medium API given correct token.")
    #+END_SRC
    
** Functions
*** Test if a integration token exists
    Before doing anything else, test if the integration token is empty. If empty, prompt user to go to medium.com, get an integration token and set the variable.

    #+BEGIN_SRC elisp
      (defun org-medium-test-token ()
        "Test if the integration token for medium is present. If not, ask the user to get one and open the url for user."
        (if (eq 0 (length org-medium-integration-token))
            (progn
              (if (y-or-n-p "Your integration token is not set, take you to medium so you can get one? (y/n): ")
                  (browse-url-default-browser "https://medium.com/me/settings")
                (message "Please set variable org-medium-integration-token."))
              (signal 'quit nil))))
    #+END_SRC
*** Get author's ID
    To create a post, one must send a POST request to the API endpoint, part of which is the author's ID.

    Get author ID from Medium:
    #+BEGIN_SRC elisp
      (defun org-medium-get-authorid ()
        "Obtain author information from Medium and return the id for later use"
        ()
        (org-medium-test-token)
        (org-medium-me-query))
    #+END_SRC
    
    #+BEGIN_SRC elisp
      (defun org-medium-me-query ()
        "Query Medium for user information."
        ()
        (let* ((url-request-method "GET")
               (auth-token (concat "Bearer " org-medium-integration-token))
               (url-request-extra-headers
                `(("Content Type" . "application/json")
                  ("Accept" . "application/json")
                  ("Authorization" . ,auth-token)
                  ("Accept-Charset" . "utf-8"))))
          (url-retrieve org-medium-apiuser 'org-medium-json-parse)))

      (defun org-medium-json-parse (status)
        "Parse JSON to extract required data from response."
        (switch-to-buffer (current-buffer))
        (set-window-point (selected-window) (point-min))
        (search-forward-regexp "\"id\":\"\\([0-9abcdef]*\\)")
        (setq org-medium-author-id (current-word))
	(kill-buffer))
    #+END_SRC
    
    Things I learned writing these two functions: you can use backquote, instead of quote, to quote a list. In this case, you can use a comma in a backquoted list to force evaluation of lists and variables. Alternatively, you can use ~cons~ to construct an association list, which evaluates the values before creating the key-value pair. You don't always need ~json.el~. You can use search and 'current-word' to extract useful information. 
*** Generate data from Org-Mode file
    The API accepts the following parameters:
    | Parameter     | Type         | Required? |
    |---------------+--------------+-----------|
    | title         | string       | y         |
    | contentFormat | string       | y         |
    | content       | string       | y         |
    | tags          | string array | n         |
    | canonicalUrl  | string       | n         |
    | publishStatus | enum         | n         |
    | license       | enum         | n         |

    Below are some experiment space for optimized output:
    
    #+BEGIN_SRC elisp :tangle no
      (org-html-export-as-html nil nil nil t '(:with-toc  nil))
    #+END_SRC
    
    The above code seems good enough. When running the code, Emacs opens a HTML buffer in another window, the generated HTML only have the ~<body>~ part, so the content part can be generated with this.

    How do I get title?

    #+BEGIN_SRC elisp
      (defun org-medium-get-title ()
        "Get title from the #+TITLE keyword of current document."
        (interactive)
        (save-excursion
          (goto-char (point-min))
          (search-forward-regexp "#\\+title:\\ *")
          (let ((beg (point))) (end-of-line) (buffer-substring-no-properties beg (point)))))
    #+END_SRC
    
    Then we can create the json and post it to Medium:

    #+BEGIN_SRC elisp
      (defun org-medium-post ()
        "Publish your post to Medium."
        (interactive)
        (let* ((url-request-method "POST")
               (auth-token (concat "Bearer" org-medium-integration-token))
               (url-request-extra-headers
                `(("Content Type" . "application/json")
                  ("Accept" . "application/json")
                  ("Authorization" . ,auth-token)
                  ("Accept-Charset" . "utf-8")))
               (content (org-html-export-as-html nil nil nil t '(:with-toc  nil)))
               (title (org-medium-get-title))
               (content-format "html")
               (url-request-data (json-encode-plist `(:title ,title
                                                             :content ,content
                                                             :contentFormat ,content-format)))
               (url (concat org-medium-apibegin "/" org-medium-author-id "/posts")))
          (url-retrieve url (lambda (status) (switch-to-buffer (current-buffer))))))
    #+END_SRC
    
** Postamble
   #+BEGIN_SRC elisp
     (provide 'org-sendto-medium)
     ;;; org-sendto-medium.el ends here
   #+END_SRC
  
* Ideas/Road Map
** Allow using curl to talk with Medium in async mode
** Allow user to choose whether publish the whole file or a subtree
* References

  - [[https://medium.com/developers/welcome-to-the-medium-api-3418f956552#.7kpre5bjs][Welcome to the Medium API]]
  - [[https://github.com/Medium/medium-api-docs][Medium API Docs]] 
  - [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Simple-Packages.html][Simple Packages]]
  - [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Library-Headers.html#Library-Headers][Conventional Headers for Emacs Libraries]]
  - https://github.com/lambtron/medium-cli/blob/master/lib/medium.js#L35-L46 Using integration token
